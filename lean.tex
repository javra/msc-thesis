My main goal in this thesis project was the formalization and application of
Ronald Brown's structures for non-abelian algebraic topology in the theorem prover
Lean.
Lean, at the point of time when I started working on it, was still in a very early
stage of development and did not lack any automation but also a basic library
for homotopy type theory.
Thus, we will first take a look at the basic language elements and technologies
used in Lean and then describe the strategies, the structure and the pitfalls
we encountered when building up a library for basic homotopy type theory,
for categories in homotopy type theory, and finally for double groupoids and
crossed modules.

\section{The Lean Theorem Prover}

The development of the theorem prover Lean was initiated in 2013 by Leo\-nar\-do
de Moura and Jeremy Avigad.
De Moura had previously been working on the automated theorem prover Z3, the leading
solver for problem sets in the SMT standard.
With Lean, he intends to create a interactive theorem proving system that connects
the strength of solvers like Z3 with the expressiveness and flexibility of
interactive systems like Agda, Coq or Isabelle.
While in the world of automated theorem proving the verification of a statement
results in a yes-or-no answer at best accompanied by a counterexample in the case
that the statement gets refuted, in interactive theorem proving, we are interested
in an actual proof that a statement is correct.
Since in homotopy type theory it is relevant which proof of a theorem we assume
and since proofs of theorems can be part of another definition or theorem,
the proofs in an interactive theorem prover suitable for homotopy type theory
should even be objects in the language itself.
Lean has two modes: One for standard, proof irrelevant mathematics and one for
In the following, I will only explain the features of the HoTT mode.
homtopy type theory.

A first ingredient are \textbf{type universes}.
Instead of using $\UU$, universes in Lean are denoted as \leani{Type.{l}}, where
\leani{l} is the level of the universe.
Of course, \leani{Type.{l}} is an object of \leani{Type.{l+1}}.
But in contrast to homotopy type theory as presented in the HoTT book \cite{hottbook},
type universes in Lean are \emph{non-cumulative}, 
i.e. \leani{A : Type.{l}} does not entail \leani{A : Type.{l+1}}.

Definitions can be \emph{universe polymorphic}, which means that, when no concrete
universe levels are given, Lean will keep the definition as general as possible.
The instantiation of a definition \leani{A} at a universe \leani{l} can be received
manually by writing \leani{A.{l}}.
To have manual control over the coherence of universe levels of definitions in
a certain scope, variable universe levels can be declared using the command
\leani{universe variable}. The following snippet shows universe polymorphism
and the use of universe variables:
\begin{leancode}
check Type -- Prints Type.{l_1} : Type.{l_1+1}

universe variable l
check Type.{l} -- Prints Type.{l} : Type.{l+1}
\end{leancode}

The only built-in type formers are (dependent and non-dependent) function types,
structures, and inductive datatypes.

The \textbf{type of functions} between types \leani{A} and \leani{B} is written
as \leani{A → B}.
\leani{A} and \leani{B} do not have to lie in the same universe to form this type
and the universe level of the function type is the maximum of the level of domain
and codomain type.
Lambda abstraction and function application can be written like known from e.g.
Haskell.
$\beta$ reduction is done for each output, $\eta$ conversion is applied when necessary
in the unification process.
\begin{leancode}
variables (A B : Type) (a : A) (b : B) (f : A → B)

check A → B -- Prints A → B : Type.{max l_1 l_2}
check (λ (x : A), b) -- Prints λ (x : A), b : A → B
check (f a) -- Prints f a : B
check (λ x, f x) a -- Prints f a : B
\end{leancode}

An important special case of non-dependent function types are type families
of the form \leani{A → Type}. For every \leani{P : A → Type} we can form the
\textbf{$\Pi$-type} \leani{Π (x : A), P x} over \leani{P}.
Actually, non-dependent function types are just treated as the special case of
dependent functions where \leani{P} is constant.
The $\Pi$-type \leani{Π (x : A), B} for \leani{A B : Type} is automatically reduced
to \leani{A → B}.
\begin{leancode}
variables (A B : Type) (P : A → Type) (Q : Π (x : A) , P x → Type)
variables (p : Π (x : A), P x) (a : A)

check p a -- Prints p a : P a
check Q a -- Prints Q a : P a → Type
check (λ (x : A), Q x (p x)) -- Prints λ (x : A), Q x (p x) : A → Type
\end{leancode}

Lean furthermore allows the definition of inductive types and inductive
families.
To construct an \textbf{inductive type}, one must give a list of parameters the type should
depend on and a list of constructors.
This makes the definition of important types like the natrual numbers or the identity
type possible.
The dependent recursor for inductive types is generated automatically by the kernel:
\begin{leancode}
inductive nat : Type :=
  zero : nat,
  succ : nat → nat
check nat.succ nat.zero) -- Prints nat.succ nat.zero : nat
check @nat.rec_on -- Prints Π {C : nat → Type} (n : nat), C nat.zero →
                  --        (Π (a : nat), C a → C (nat.succ a)) → C n
\end{leancode}

\begin{leancode}
inductive eq (A : Type) (a : A) : A → Type :=
  refl : eq A a a
variables (A : Type) (a : A)
check @eq.refl A a -- Prints eq.refl a : eq A a a
check @eq.rec_on A a -- Prints Π {C : Π (a_1 : A), eq A a a_1 → Type}
                     --        {a_1 : A} (n : eq A a a_1),
                     --        C a (eq.refl a) → C a_1 n
\end{leancode}

We can not only define single inductive types but also \textbf{families of
inductive types}, which we can define by recursion on the index of the family:
\begin{leancode}
open nat

inductive vec (A : Type) : ℕ → Type :=
  nil : vec A 0,
  cons : Π (n : ℕ), A → vec A n → vec A (n+1)

open vec
variables (A : Type) (a : A)
check @vec.rec_on A -- Prints Π {C : Π (a : ℕ), vec A a → Type} {a : ℕ} 
                    --        (n : vec A a), C 0 (nil A) →
                    --        (Π (n : ℕ) (a : A) (a_1 : vec A n), C n a_1
                    --          → C (n + 1) (cons n a a_1)) →
                    --        C a n
check cons 0 a (nil A) -- Prints cons 0 a (nil A) : vec A (0+1)
\end{leancode}

A widely used subclass of inductive types are \textbf{structures}, also often
referred to as "records".
Structures are inductive types which are non-recursive and only have one constructor.
That means that they are equivalent to iterated sigma types but, among other advantages,
have named projections.
Structures provide a basic inheritance mechanism as they can extend arbitrarily
many other structures with \textbf{coercions} being added for each parent structure:
\begin{leancode}
structure graph (V : Type₀) :=
  (E : V → V → Type₀)

structure refl_graph (V : Type₀) extends graph V :=
  (refl : Π (v : V), E v v)

structure trans_graph (V : Type₀) extends graph V :=
  (trans : Π (u v w : V), E u v → E v w → E u w)

structure refl_trans_graph (V : Type₀) extends refl_graph V, trans_graph V

variables (V : Type₀)
check graph.E (refl_graph.mk (λ (a b : V), a = b) eq.refl)
/- Prints
  graph.E (refl_graph.to_graph 
    (refl_graph.mk (λ (a b : V), a = b) eq.refl)) :
    V → V → Type₀ -/
\end{leancode}

As one can already seen in these small examples, writing out the full names and
the complete list of parameters for each call of a defined function can be very
tedious.
Lean implements some features that allow its users to make theory files more
succinct and readable by leaving out information that can be inferred automatically
by Lean.

One feature that allows more brevity are \textbf{implicit arguments}.
To mark an argument to a definition to be automatically inferred by Lean,
the user can mark it with curly brackets instead of round brackets when listing
it in the signatur of the definition.
Of course the missing arguments have to be such that they can be uniquely determined
by the unification process, otherwise the unifier will return an appropriate error
message whenever the definition is used.
By default, implicit arguments are \emph{maximally inserted}.
That means, that any expression of a $\Pi$-type with its first argument implicit
is not interpreted as is but further applied by inference of that argument.
By using double curly brackets \leani{⦃...⦄} instead of single curly brackts,
the user can change this behaviour to be more passive by only inferring the argument
if it precedes a explicitely stated one:
\begin{leancode}
definition inverse {P : Type} {x y : P} (p : x = y) : y = x :=
  eq.rec (eq.refl x) p
check inverse -- Prints inverse : ?x = ?y → ?y = ?x

definition id ⦃A : Type⦄ (a : A) := A
check id -- Prints id : Π ⦃A : Type⦄, A → Type

variables {A : Type} (a : A)
check id a -- Prints id a : Type
\end{leancode}

Another useful feature to organize formalizations and shorten code is the interaction
between namespaces and overloading.
In general there are no restrictions on \textbf{overloading} theorem names but each additional
overload with the same name makes it harder for the elaborator to figure out which
one it needs to use in a certain case.
To make overloads more organized, definitions can be put in hierarchical \textbf{namespaces}
which can be opened selectively.
Opening a namespace makes each theorem in that namespace available to be called
with its name as stated in the definition inside that namespace, as opposed to
giving its absolute name.
Definitions can be marked as \leani{protected} to prevent their names from being
pruned and as \leani{private} to exclude them from exporting completely.
Furthermore, opening namespaces enables the use of \textbf{notations} defined
in that namespace.
\begin{leancode}
open nat

namespace exponentiation
  definition squared (a : ℕ) := a * a
  notation a`²`:100 := squared a
end exponentiation

open exponentiation
check squared -- Prints squared : ℕ → ℕ
eval 4² -- Prints 16
\end{leancode}
Often, consecutive definitions share a lot of arguments.
To avoid the need to repeat those arguments for each definition, Lean provides
\textbf{sections} and \textbf{contexts} which serve as scopes for common variables.
Variables declared in sections is persistent while variables in contexts will not
be accessible after closing the scope.
Besides \leani{variables}, there are \leani{parameters} which will not be generalized
until the context or section is closed.

One last feature helping to create short and readable files are \textbf{type
classes}.
After marking an inductive type or a family of inductive type as \leani{[class]},
we can declare definitions that are objects of this type as \leani{[instance]}.
Then, we can use a fourth mode of argument implicitness (besides \leani{(...)},
\leani{{...}}, and \leani{⦃...⦄}) denoted by \leani{[...]} to tell Lean that it
should infer this argument by filling in one of the instances of the required
type.
The selection of one out of several fitting instances can be influenced by assigning
priorities to the instance declarations.

\section{Basic Homotopy Type Theory in Lean}

\section{Category Theory in Lean}

\section{Formalizing Double Groupoids and Crossed Modules}

\section{Instantiating the Fundamental Double Groupoid}
